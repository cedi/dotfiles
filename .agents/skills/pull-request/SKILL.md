---
name: pull-request
description: Create GitHub pull requests using the gh CLI with conventional commit
  titles and structured, human-written descriptions that cover goal, rationale,
  and concrete before/after examples where applicable.
---

# Pull Request Creation

Create pull requests that are structured enough to scan quickly but written in a natural voice. Every PR should make the goal, reasoning, and impact clear without reading like it was generated by a tool.

## When to Use This Skill

- User asks to create a pull request
- User asks to open a PR
- User asks to submit changes for review

## Principles

### Title: Conventional Commits

The PR title MUST follow the conventional commit format:

```
<type>(<scope>): <short summary>
```

**Types:**

| Type         | When to use                                          |
| ------------ | ---------------------------------------------------- |
| `feat`       | A new capability or behavior                         |
| `fix`        | A bug fix                                            |
| `refactor`   | Code change that neither fixes a bug nor adds a feature |
| `docs`       | Documentation only                                   |
| `chore`      | Build, CI, tooling, dependencies                     |
| `test`       | Adding or correcting tests                           |
| `perf`       | Performance improvement                              |
| `style`      | Formatting, whitespace, naming (no logic change)     |
| `ci`         | CI/CD configuration                                  |

**Scope** is optional but encouraged. Use the area of the codebase affected (e.g., `auth`, `api`, `billing`, `ui`).

**Summary** should be lowercase, imperative mood, no period at the end.

Examples:
- `feat(auth): add SSO login via SAML`
- `fix(billing): prevent double-charge on retry`
- `refactor(api): simplify error handling middleware`
- `chore(deps): bump openssl to patch CVE-2024-1234`

### Description: Structured but Human

The description should be easy to scan and technically useful, while still reading like a real person wrote it. Use lightweight section headers to give structure, but write the content in a natural voice. No corporate jargon, no LLM filler.

**Structure:**

Use these sections as a template. Skip any that don't apply. Headers should be simple `##` markdown headers with short, plain names.

```
## Goal

What this change sets out to accomplish, in one or two sentences. State the
outcome, not the mechanics.

## Rationale

Why we're doing this now, and why this particular approach. What's the context?
What alternatives were considered and why they didn't win? This is where the
reasoning lives, and it's the most valuable part of the description for
reviewers.

## Changes

A concise summary of what actually changed, written for someone who hasn't
looked at the diff yet. Focus on the important moving parts, not a file-by-file
inventory. A short paragraph or a few bullet points both work, whichever fits
the change better.

## Before / After

(Optional) When behavior changes in a way that's easier to show than explain,
include concrete examples. Code snippets, API responses, CLI output, UI states,
whatever makes the difference clear. Skip this for refactors or internal
plumbing where there's no user-visible change.

## Notes

(Optional) Anything reviewers should know: edge cases, follow-up work,
migration steps, risks, things to watch in production. Keep it short.
```

**Voice rules:**

Write in a natural, direct tone. Short paragraphs, plain language. First person is fine.

Skip the obvious. Don't describe things the diff already shows clearly.

No AI patterns. Avoid words like "comprehensive", "robust", "enhance", "streamline", "leverage", "seamless", "cutting-edge". No "This PR does X" opening. No emoji headers.

Never use em-dashes. Use commas, periods, or parentheses instead.

Never use the bolded-prefix-then-explanation bullet pattern (e.g., "**Thing**: explanation"). This pattern is a dead giveaway of AI-generated text. If you use bullets, keep them short and uniform without bolded lead-ins.

Don't pad. If the change is small, the description should be small. A two-line goal and a sentence of rationale is perfectly fine for a small fix.

**Good description:**

```
## Goal

Let Enterprise customers do bulk imports without hitting rate limits.

## Rationale

We've been getting support tickets from Enterprise customers who hit the
100/min rate limit during bulk imports. That limit was set conservatively
when we first launched the API and doesn't account for plan tiers.

I went with a token-bucket algorithm instead of the existing sliding window
because it handles bursts better, which is exactly the import use case. A
sliding window would still throttle legitimate bursts even with a higher
ceiling.

## Changes

The rate limiting middleware now checks the user's plan tier and applies
different limits (Enterprise gets 500/min, up from the flat 100/min). The
token-bucket implementation replaces the sliding window in the hot path
but the old code is still available behind a feature flag in case we need
to roll back.

## Before / After

```
# Before: Enterprise user during bulk import
HTTP 429 Too Many Requests
X-RateLimit-Limit: 100
X-RateLimit-Remaining: 0

# After: same user, same load
HTTP 200 OK
X-RateLimit-Limit: 500
X-RateLimit-Remaining: 342
X-RateLimit-Plan: enterprise
```

## Notes

The response now includes an `X-RateLimit-Plan` header. This is additive
and non-breaking, but worth knowing about if you maintain API client
libraries.
```

**Bad description (don't do this):**

```
## Summary
This PR enhances the rate limiting system with comprehensive
plan-aware functionality.

## Changes
- Modified `middleware/rate_limit.go` to add plan detection
- Updated `config/limits.yaml` with new tier values
- Added `X-RateLimit-Plan` header to responses
- Updated tests in `rate_limit_test.go`

## Testing
- Unit tests added
- Manual testing performed
```

**Also bad (the bolded-prefix bullet pattern):**

```
- **Plan-aware limiting**: Added logic to detect the user's plan
  tier and apply different rate limits accordingly.
- **Token bucket algorithm**: Replaced the sliding window approach
  with a token bucket for better burst handling.
- **New response header**: Added `X-RateLimit-Plan` so clients can
  check their tier programmatically.
```

## Workflow

### Step 1: Understand the Changes

Before writing anything, understand the full picture:

```bash
# See what branch we're on and its status
git status

# See all commits on this branch vs the base
git log --oneline main..HEAD  # adjust base branch as needed

# See the full diff
git diff main...HEAD
```

Read ALL commits, not just the latest one. The PR covers the entire branch.

### Step 2: Identify the Base Branch

Determine the correct base branch:

```bash
# Check the default branch
gh repo view --json defaultBranchRef -q '.defaultBranchRef.name'
```

### Step 3: Push if Needed

```bash
# Check if remote tracking is set up
git status -sb

# Push with upstream tracking if needed
git push -u origin HEAD
```

### Step 4: Craft the Title

Based on the full set of changes, write a conventional commit title. Pick the type that represents the primary intent of the branch, even if there are mixed commit types.

### Step 5: Write the Description

Follow the section template (Goal, Rationale, Changes, Before/After, Notes). Skip sections that don't apply. Write the Goal and Rationale first since those are the most valuable parts for reviewers, then fill in the rest.

If the change is small and obvious, Goal + Rationale might be all you need. Don't pad.

### Step 6: Create the PR

```bash
gh pr create --title "<title>" --body "$(cat <<'EOF'
<description>
EOF
)"
```

### Step 7: Return the URL

Always return the PR URL so the user can access it directly.

## Edge Cases

For single-commit branches, the commit message might be enough context. Still write a proper description but keep it brief.

If the user says "draft" or "WIP", add the `--draft` flag. If they specify a base branch, use `--base <branch>`. Reviewers can be assigned with `--reviewer <handle>` and labels with `--label <label>` when requested.
